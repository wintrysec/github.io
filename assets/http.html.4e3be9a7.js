import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as n,e as s}from"./app.4272ecb1.js";const t="/assets/http_request.6ce5514d.png",d="/assets/http_response.1dd5520d.png",p={},c=s('<h2 id="http协议概述" tabindex="-1"><a class="header-anchor" href="#http协议概述" aria-hidden="true">#</a> HTTP协议概述</h2><p>HTTP 是一种能够获取如 HTML 这样的网络资源的通讯协议(超文本传输协议)。</p><p>是一种 <code>client-server</code> 协议，客户端和服务端通过交换各自的消息进行交互。由像浏览器这样的客户端发出的消息叫做 <code>request</code>，被服务端响应的消息叫做 <code>response</code>。</p><p>一个完整的 Web 文档通常是由不同的子文档拼接而成的，像是文本、图片、视频、脚本等等。</p><h3 id="http-是无状态-有会话的" tabindex="-1"><a class="header-anchor" href="#http-是无状态-有会话的" aria-hidden="true">#</a> HTTP 是无状态，有会话的</h3><p>HTTP 是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。</p><p>这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。</p><p>而使用 HTTP 的头部扩展，HTTP Cookies 就可以解决这个问题。把 Cookies 添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</p><p>注意，HTTP 本质是无状态的，使用 Cookies 可以创建有状态的会话。</p><h3 id="http连接" tabindex="-1"><a class="header-anchor" href="#http连接" aria-hidden="true">#</a> HTTP连接</h3><p>一个连接是由传输层来控制的，这从根本上不属于 HTTP 的范围。HTTP 并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP 是可靠的，而 UDP 不是。因此，HTTP 依赖于面向连接的 TCP 进行消息传递，但连接并不是必须的。</p><p>在客户端（通常指浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个 TCP 链接，打开一个 TCP 连接需要多次往返交换消息（因此耗时）。HTTP/1.0 默认为每一对 HTTP 请求/响应都打开一个单独的 TCP 连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个 TCP 链接更低效。</p><p>为了减轻这些缺陷，HTTP/1.1 引入了流水线（被证明难以实现）和持久连接的概念：底层的 TCP 连接可以通过<code>Connection</code>头部来被部分控制。HTTP/2 则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。</p><p>HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”。</p><p>HTTP/1.1 默认使用长连接（持久化连接）。</p><h3 id="http建立连接的过程" tabindex="-1"><a class="header-anchor" href="#http建立连接的过程" aria-hidden="true">#</a> HTTP建立连接的过程</h3><ol><li>在TCP连接上发送HTTP报文；根据规则， 只有低层协议建立之后才能进行高层协议的连接</li><li>发送请求行，<code>GET /dir/xx.php HTTP/1.1</code></li><li>发送请求头，浏览器发送一行空白行来告知服务器结束请求头信息发送</li><li>服务器响应， <strong>HTTP/1.1 200 OK</strong>（协议版本号和HTTP状态码）</li><li>服务器发送响应头，服务器自己的相关信息（同样用空白行表示结束响应头）</li><li>服务器向浏览器发送数据， 以 <code>Content-Type</code> 响应头信息所描述的格式发送用户所请求的实际数据</li><li>服务器关闭TCP连接，如果请求头或响应头加了这行 <code>Connection:keep-alive</code>，会保持连接</li></ol><h3 id="http报文" tabindex="-1"><a class="header-anchor" href="#http报文" aria-hidden="true">#</a> HTTP报文</h3><h4 id="请求-request" tabindex="-1"><a class="header-anchor" href="#请求-request" aria-hidden="true">#</a> 请求（Request）</h4><div class="custom-container info"><p class="custom-container-title">相关信息</p><p>Method：请求方法</p><p>Path：访问网站的路径</p><p>Version：HTTP协议版本号</p><p>Headers：HTTP请求头</p></div><p><img src="'+t+'" alt="A basic HTTP request" loading="lazy"></p><h4 id="响应-response" tabindex="-1"><a class="header-anchor" href="#响应-response" aria-hidden="true">#</a> 响应（Response）</h4><div class="custom-container info"><p class="custom-container-title">相关信息</p><p>Version：HTTP协议版本号</p><p>Status code：状态码，告知对应请求执行成功或失败，以及失败的原因。</p><p>Status message：状态信息，这个信息是非权威的状态码描述信息，可以由服务端自行设定。</p><p>Headers：HTTP响应头</p></div><p><img src="'+d+`" alt="img" loading="lazy"></p><h2 id="http请求方法" tabindex="-1"><a class="header-anchor" href="#http请求方法" aria-hidden="true">#</a> HTTP请求方法</h2><table><thead><tr><th style="text-align:left;">请求方法</th><th>作用</th></tr></thead><tbody><tr><td style="text-align:left;">GET</td><td>请求指定的资源，只用于获取数据</td></tr><tr><td style="text-align:left;">POST</td><td>发送数据给服务器。请求主体的类型由 <code>Content-Type</code> 首部指定</td></tr><tr><td style="text-align:left;">OPTIONS</td><td>用于获取目的资源所支持的请求方法</td></tr><tr><td style="text-align:left;">HEAD</td><td>请求资源的头部信息，获取资源大小，响应不包含响应体，可以节约带宽资源</td></tr><tr><td style="text-align:left;">PUT</td><td>使用请求中的负载创建或者替换目标资源</td></tr><tr><td style="text-align:left;">DELETE</td><td>删除指定的资源</td></tr><tr><td style="text-align:left;">TRACE</td><td>实现沿通向目标资源的路径的消息环回（loop-back）测试，提供了一种实用的 debug 机制</td></tr><tr><td style="text-align:left;">PATCH</td><td>用于对资源进行部分修改 补丁</td></tr><tr><td style="text-align:left;">CONNECT</td><td>开启一个客户端与所请求资源之间的双向沟通的通道。可以用来创建隧道（tunnel）</td></tr></tbody></table><div class="custom-container danger"><p class="custom-container-title">警告</p><p><code>PUT</code> 与 <code>POST</code> 方法的区别在于，PUT 方法是幂等的：调用一次与连续调用多次是等价的（即没有副作用），而连续调用多次 POST 方法可能会有副作用，比如将一个订单重复提交多次。</p><p>如果目标资源不存在，并且 PUT 方法成功创建了一份，那么源头服务器必须返回<code>201</code> (<code>Created</code>) 来通知客户端资源已创建。</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">201</span> <span class="token reason-phrase string">Created</span></span>
<span class="token header"><span class="token header-name keyword">Content-Location</span><span class="token punctuation">:</span> <span class="token header-value">/new.html</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果目标资源已经存在，并且依照请求中封装的表现形式成功进行了更新，那么，源头服务器必须返回<code>200</code> (<code>OK</code>) 或者<code>204</code> (<code>No Content</code>) 来表示请求的成功完成。</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">204</span> <span class="token reason-phrase string">No Content</span></span>
<span class="token header"><span class="token header-name keyword">Content-Location</span><span class="token punctuation">:</span> <span class="token header-value">/existing.html</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></div><h2 id="http状态码" tabindex="-1"><a class="header-anchor" href="#http状态码" aria-hidden="true">#</a> HTTP状态码</h2><p>状态码类别</p><table><thead><tr><th></th><th style="text-align:left;">类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td style="text-align:left;">Informational（信息性状态码）</td><td>接受的请求正在处理</td></tr><tr><td>2XX</td><td style="text-align:left;">Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td style="text-align:left;">Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td style="text-align:left;">Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td style="text-align:left;">Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><details class="custom-container details"><summary>常见状态码（点击展开）</summary><p>100：表示收到请求消息头，客户端应继续发送主体</p><p>200：请求被正常处理</p><p>201：PUT请求返回这个状态码，表示请求已成功提交</p><p>204：请求被受理但没有资源可以返回</p><p>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</p><p>301：永久性重定向</p><p>302：临时重定向</p><p>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</p><p>304：发送附带条件的请求时，条件不满足时返回，指示浏览器使用缓存中所请求资源的副本</p><p>307：临时重定向，与302类似，只是强制要求使用POST方法</p><p>400：请求报文语法有误，服务器无法识别</p><p>401：请求需要认证</p><p>403：请求的对应资源禁止被访问</p><p>404：服务器无法找到对应资源</p><p>405：不支持请求中使用的请求方法</p><p>413：请求主体过长，服务器无法处理 (探查缓冲区溢出时会有)</p><p>414：请求URL过长，服务器无法处理</p><p>500：服务器内部错误</p><p>503：服务器正忙，用来说明服务器现在无法为请求提供服务，但将来可以 (服务器负载过大)</p></details><h2 id="http请求头" tabindex="-1"><a class="header-anchor" href="#http请求头" aria-hidden="true">#</a> HTTP请求头</h2><h3 id="accept" tabindex="-1"><a class="header-anchor" href="#accept" aria-hidden="true">#</a> <strong><code>Accept</code></strong></h3><p>用来告知（服务器）客户端可以处理的内容类型，这种内容类型用MIME 类型来表示。</p><details class="custom-container details"><summary>展开语法</summary><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">image/*</span></span>
<span class="token header"><span class="token header-name keyword">Accept</span><span class="token punctuation">:</span> <span class="token header-value">text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="accept-charset" tabindex="-1"><a class="header-anchor" href="#accept-charset" aria-hidden="true">#</a> <strong><code>Accept-Charset</code></strong></h3><p>用来告知（服务器）客户端可以处理的字符集类型</p><details class="custom-container details"><summary>展开语法</summary><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Accept-Charset</span><span class="token punctuation">:</span> <span class="token header-value">iso-8859-1</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Charset</span><span class="token punctuation">:</span> <span class="token header-value">utf-8, iso-8859-1;q=0.5</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Charset</span><span class="token punctuation">:</span> <span class="token header-value">utf-8, iso-8859-1;q=0.5, *;q=0.1</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="accept-encoding" tabindex="-1"><a class="header-anchor" href="#accept-encoding" aria-hidden="true">#</a> <code>Accept-Encoding</code></h3><p>将客户端能够理解的内容编码方式，通常是某种压缩算法，通知给服务端</p><details class="custom-container details"><summary>展开语法</summary><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">gzip</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">compress</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">deflate</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">br</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">identity</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">*</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="authorization" tabindex="-1"><a class="header-anchor" href="#authorization" aria-hidden="true">#</a> <code>Authorization</code></h3><p>请求消息头含有服务器用于验证用户代理身份的凭证，通常会在服务器返回<code>401</code> <code>Unauthorized</code> 状态码以及<code>WWW-Authenticate</code> 消息头之后在后续请求中发送此消息头。</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Authorization</span><span class="token punctuation">:</span> <span class="token header-value">Basic YWxhZGRpbjpvcGVuc2VzYW1l</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="connection" tabindex="-1"><a class="header-anchor" href="#connection" aria-hidden="true">#</a> <code>Connection</code></h3><p>决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成。</p><details class="custom-container details"><summary>展开语法</summary><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">keep-alive</span></span>
<span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">close</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="x-forwarded-for-xff" tabindex="-1"><a class="header-anchor" href="#x-forwarded-for-xff" aria-hidden="true">#</a> <code>X-Forwarded-For (XFF)</code></h3><p>获取最初发起请求的客户端的 IP 地址，也是一个电子邮件相关协议中用到的首部，用来表示一封电子邮件是从其他账户转发过来的。</p><p>如果一个请求经过了多个代理服务器，那么每一个代理服务器的 IP 地址都会被依次记录在内。</p><p>也就是说，最右端的 IP 地址表示最近通过的代理服务器，而最左端的 IP 地址表示最初发起请求的客户端的 IP 地址。</p><details class="custom-container details"><summary>展开语法</summary><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">X-Forwarded-For</span><span class="token punctuation">:</span> <span class="token header-value">&lt;client&gt;, &lt;proxy1&gt;, &lt;proxy2&gt;</span></span>
<span class="token header"><span class="token header-name keyword">X-Forwarded-For</span><span class="token punctuation">:</span> <span class="token header-value">2001:db8:85a3:8d3:1319:8a2e:370:7348</span></span>
<span class="token header"><span class="token header-name keyword">X-Forwarded-For</span><span class="token punctuation">:</span> <span class="token header-value">47.11.22.33</span></span>
<span class="token header"><span class="token header-name keyword">X-Forwarded-For</span><span class="token punctuation">:</span> <span class="token header-value">47.11.22.33, 70.41.3.18, 150.172.238.178</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="更多其它头部" tabindex="-1"><a class="header-anchor" href="#更多其它头部" aria-hidden="true">#</a> <code>更多其它头部</code></h3><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">缓存的控制 </span></span>
<span class="token header"><span class="token header-name keyword">Transfer-Encoding</span><span class="token punctuation">:</span> <span class="token header-value">报文主体的传输编码方式</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">请求资源所在服务器和端口号 Accept: 可处理的媒体类型 Accept-Charset: 可接收的字符集 Accept-Encoding: 可接受的内容编码 Accept-Language: 可接受的自然语言</span></span>
<span class="token header"><span class="token header-name keyword">Cookie</span><span class="token punctuation">:</span> <span class="token header-value">用于向服务器提交它以前发布的cookie</span></span>
<span class="token header"><span class="token header-name keyword">If-Modified-Since</span><span class="token punctuation">:</span>  <span class="token header-value">用于说明最后一次收到所请求资源的时间，如果自那之后资源没有变化，服务器会返回一个状态码304的响应，指示客户端使用资源的缓存副本</span></span>
<span class="token header"><span class="token header-name keyword">If-None-Match</span><span class="token punctuation">:</span> <span class="token header-value">用于指定一个实体标签,当最后一次收到所请的求资源时，浏览器提交服务器发布的实体标签,服务器可以使用实体标签，确认浏览器是否使用资源的缓存副本</span></span>
<span class="token header"><span class="token header-name keyword">Origin</span><span class="token punctuation">:</span> <span class="token header-value">用在Ajax跨域请求中，用于指示提出请求的域</span></span>
<span class="token header"><span class="token header-name keyword">Referer</span><span class="token punctuation">:</span> <span class="token header-value">指示发出当前请求的原始URL</span></span>
<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span> <span class="token header-value">提供生成请求客户端软件的有关信息</span></span>
<span class="token header"><span class="token header-name keyword">Allow</span><span class="token punctuation">:</span> <span class="token header-value">资源可支持的HTTP方法 </span></span>
<span class="token header"><span class="token header-name keyword">Location</span><span class="token punctuation">:</span> <span class="token header-value">在重定向响应中，说明重定向的目标 </span></span>
<span class="token header"><span class="token header-name keyword">Server</span><span class="token punctuation">:</span> <span class="token header-value">提供所使用的Web服务器软件的信息</span></span>
<span class="token header"><span class="token header-name keyword">Accept-Ranges</span><span class="token punctuation">:</span> <span class="token header-value">可接受的字节范围</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">规定消息主体的类型 Content-Encoding: 实体主体适用的编码方式，一些应用程序用它压缩响应加快传输 Content-Language: 实体主体的自然语言 Content-Length: 规定消息主体的字节长度 (HEAD方法例外) Content-Range: 实体主体的位置范围，一般用于发出部分请求时使用</span></span>
<span class="token header"><span class="token header-name keyword">Transfer-Encoding</span><span class="token punctuation">:</span>  <span class="token header-value">chunked 分块传输；常用它指定块编码，它是指定HTTP传输对消息主体使用的任何编码的</span></span>
<span class="token header"><span class="token header-name keyword">Access-Control-Allow-Origin</span><span class="token punctuation">:</span> <span class="token header-value">指示可否通过跨域Ajax请求获取资源</span></span>
<span class="token header"><span class="token header-name keyword">Set-Cookie</span><span class="token punctuation">:</span> <span class="token header-value">用于向浏览器发布Cookie，浏览器会在随后的请求中将其返回给服务器</span></span>
<span class="token header"><span class="token header-name keyword">WWW-Authenticate</span><span class="token punctuation">:</span> <span class="token header-value">在带401状态码的响应中，提供与服务器所支持的身份验证类型的有关信息 (如基础认证)</span></span>
<span class="token header"><span class="token header-name keyword">X-Frame-Options</span><span class="token punctuation">:</span> <span class="token header-value">指示浏览器框架是否加载以及如何加载当前响应</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,54),o=[c];function l(r,i){return e(),n("div",null,o)}const k=a(p,[["render",l],["__file","http.html.vue"]]);export{k as default};
