import{_ as t}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as a,e as p}from"./app.4272ecb1.js";const d="/assets/image-20221115164642031.1e265b91.png",r="/assets/TCP3.f0c3ec54.png",s="/assets/TCP4.46d31771.png",l={},i=p('<h2 id="tcp-ip族" tabindex="-1"><a class="header-anchor" href="#tcp-ip族" aria-hidden="true">#</a> TCP/IP族</h2><p>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。</p><p>因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><p><img src="'+d+'" alt="" loading="lazy"></p><h2 id="tcp-ip协议分层模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip协议分层模型" aria-hidden="true">#</a> TCP/IP协议分层模型</h2><p>OSI 参考模型注重 “通信协议必要的功能是什么”</p><p>而 TCP/IP模型 则更强调“在计算机上实现协议应该开发哪种程序”。</p><h3 id="osi七层模型" tabindex="-1"><a class="header-anchor" href="#osi七层模型" aria-hidden="true">#</a> OSI七层模型</h3><p>1、物理层：负责0、1比特流与电压的高低，光的闪灭之间的互换；双绞线，无线，光纤</p><p>2、数据链路层：负责物理层面上的互连、节点间的通信传输；以太网，无线网，PPP</p><p>3、网络层：负责寻址和路由选择；ARP，ICMP、IPv4，IPv6，IPsec</p><p>4、传输层：起可靠传输作用，只在通信双方节点进行处理；TCP，UDP</p><p>5、会话层：负责建立和断开通信连接</p><p>6、表示层：负责数据格式的转换</p><p>7、应用层：提供应用程序通信细节；Telnet，SSH，HTTP，SMTP，SSL/TLS，FTP，SNMP</p><h3 id="tcp-ip四层模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip四层模型" aria-hidden="true">#</a> TCP/IP四层模型</h3><p>1、应用层：对应OSI参考模型的高层，提供各种服务</p><p>2、传输层：为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性</p><p>3、网际互联层：主要解决主机到主机的通信问题 ，有三个主要协议：</p><ul><li>网际协议（IP）</li><li>互联网组管理协议（IGMP）</li><li>互联网控制报文协议（ICMP）</li></ul><p>4、网络接入层： 负责监视数据在主机和网络之间的交换</p><h2 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手" aria-hidden="true">#</a> 三次握手</h2><p><img src="'+r+'" alt="TCP3" loading="lazy"></p><p><strong>第一次握手</strong>：</p><p>客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)</p><p>此时<strong>客户端</strong>处于 <code>SYN_Send</code> 状态</p><p><strong>第二次握手</strong>：</p><p>服务器收到客户端的 SYN 报文之后，以自己的 SYN 报文作为应答，并指定自己的 ISN(s)</p><p>同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN</p><p>此时服务器处于 <code>SYN_REVD</code> 的状态</p><p><strong>第三次握手</strong>：</p><p>客户端收到 SYN 报文之后，会发送一个 ACK 报文</p><p>把服务器的 ISN + 1 作为 ACK 的值表示已经收到了服务端的 SYN 报文</p><p>此时<strong>客户端</strong>处于 <code>establised </code>状态</p><p>服务器收到 ACK 报文之后，也处于 <strong>establised</strong> 状态，此时，双方已建立起了链接</p><h2 id="三次握手的作用" tabindex="-1"><a class="header-anchor" href="#三次握手的作用" aria-hidden="true">#</a> 三次握手的作用</h2><p>确认双方的接受能力、发送能力是否正常</p><p>指定自己的初始化序列号，为后面的可靠传送做准备</p><p>如果是 HTTPS 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成</p><h2 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手" aria-hidden="true">#</a> 四次挥手</h2><p>断开连接时会进行四次挥手</p><p><img src="'+s+'" alt="TCP4" loading="lazy"></p><p><strong>第一次挥手</strong>：</p><p>客户端发送一个 FIN 报文，报文中会指定一个序列号</p><p>此时客户端处于 FIN_WAIT1 状态。</p><p><strong>第二次挥手</strong>：</p><p>服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值</p><p>表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态</p><p><strong>第三次挥手</strong>：</p><p>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p><p><strong>第四次挥手</strong>：</p><p>客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答 且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。</p><p>需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。</p><p>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><h2 id="tcp-11种网络状态" tabindex="-1"><a class="header-anchor" href="#tcp-11种网络状态" aria-hidden="true">#</a> TCP-11种网络状态</h2><table><thead><tr><th style="text-align:left;">含义</th><th style="text-align:left;">状态</th></tr></thead><tbody><tr><td style="text-align:left;">LISTEN</td><td style="text-align:left;">侦听来自客户端的TCP端口连接请求</td></tr><tr><td style="text-align:left;">SYN-SENT</td><td style="text-align:left;">在发送连接请求后等待匹配的连接请求</td></tr><tr><td style="text-align:left;">SYN-RECEIVED</td><td style="text-align:left;">在收到和发送一个连接请求后等待对连接请求的确认</td></tr><tr><td style="text-align:left;">ESTABLISHED</td><td style="text-align:left;">代表一个打开的连接，数据可以传送给用户</td></tr><tr><td style="text-align:left;">FIN-WAIT-1</td><td style="text-align:left;">等待远程TCP的连接中断请求，或先前的连接中断请求确认</td></tr><tr><td style="text-align:left;">FIN-WAIT-2</td><td style="text-align:left;">从远程TCP等待连接中断请求</td></tr><tr><td style="text-align:left;">CLOSE-WAIT</td><td style="text-align:left;">等待从本地用户发来的连接中断</td></tr><tr><td style="text-align:left;">CLOSING</td><td style="text-align:left;">等待远程TCP对连接中断的确认</td></tr><tr><td style="text-align:left;">LAST-ACK</td><td style="text-align:left;">等待原来发向远程TCP的连接中断请求的确认</td></tr><tr><td style="text-align:left;">TIME-WAIT</td><td style="text-align:left;">等待足够的时间以确保远程TCP接收到连接中断请求的确认</td></tr><tr><td style="text-align:left;">CLOSED</td><td style="text-align:left;">没有任何连接状态</td></tr></tbody></table><h2 id="问题汇总" tabindex="-1"><a class="header-anchor" href="#问题汇总" aria-hidden="true">#</a> 问题汇总</h2><h3 id="三次握手过程中可以携带数据吗" tabindex="-1"><a class="header-anchor" href="#三次握手过程中可以携带数据吗" aria-hidden="true">#</a> 三次握手过程中可以携带数据吗？</h3><p>很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。</p><p>也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p><p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。</p><p>因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p><p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据没啥毛病。</p><h3 id="什么是半连接队列" tabindex="-1"><a class="header-anchor" href="#什么是半连接队列" aria-hidden="true">#</a> 什么是半连接队列？</h3><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p><p>当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><h3 id="syn-ack-重传次数的问题" tabindex="-1"><a class="header-anchor" href="#syn-ack-重传次数的问题" aria-hidden="true">#</a> SYN-ACK 重传次数的问题</h3><p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p><p>注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s</p><h3 id="time-wait-状态" tabindex="-1"><a class="header-anchor" href="#time-wait-状态" aria-hidden="true">#</a> <strong>TIME_WAIT 状态</strong></h3><p><strong>为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭？</strong></p><p>因为要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端。客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p><p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。 一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功，就是 ACK 报文，此时处于 CLOSED 状态。</p>',74),n=[i];function h(o,c){return e(),a("div",null,n)}const I=t(l,[["render",h],["__file","tcp.html.vue"]]);export{I as default};
