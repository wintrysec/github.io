import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as a,e as i}from"./app.9e3cc3d3.js";const n={},o=i(`<p>常见逻辑漏洞挖掘思路</p><h2 id="支付漏洞" tabindex="-1"><a class="header-anchor" href="#支付漏洞" aria-hidden="true">#</a> 支付漏洞</h2><h4 id="_1-密码重置" tabindex="-1"><a class="header-anchor" href="#_1-密码重置" aria-hidden="true">#</a> (1) 密码重置</h4><p>验证码直接在HTTP响应中返回；</p><p>验证码未绑定用户，没和手机号和邮箱号做匹配验证；</p><p>未校验用户字段值，改自己密码，最后提交其它UID；</p><p>验证码不失效，可枚举；</p><h4 id="_2-支付订单" tabindex="-1"><a class="header-anchor" href="#_2-支付订单" aria-hidden="true">#</a> (2) 支付订单</h4><p>篡改支付金额，运费修改为负数，使总金额降低。</p><h4 id="_3-竞争条件" tabindex="-1"><a class="header-anchor" href="#_3-竞争条件" aria-hidden="true">#</a> (3) 竞争条件</h4><p>场景：</p><p>A用户余额10元，B商品5元，C商品6元;</p><p>A利用竞争条件多线程同时发起购买B和C的请求；</p><p>可能的结果有：</p><ol><li>有一件商品购买失败</li><li>商品都购买成功，但只扣了6元</li><li>商品都购买成功，但余额为 -1元</li></ol><h2 id="越权访问" tabindex="-1"><a class="header-anchor" href="#越权访问" aria-hidden="true">#</a> 越权访问</h2><p>越权访问他人信息或操纵他人账号</p><h4 id="水平越权" tabindex="-1"><a class="header-anchor" href="#水平越权" aria-hidden="true">#</a> 水平越权：</h4><p>同级别(权限)用户之间，越权访问非法操纵其它账户；(这会导致大批量数据泄露，恶意篡改)</p><h4 id="垂直越权" tabindex="-1"><a class="header-anchor" href="#垂直越权" aria-hidden="true">#</a> 垂直越权：</h4><p>不同级别之间的用户越权，普通用户执行管理员的功能；</p><h4 id="越权访问攻击测试" tabindex="-1"><a class="header-anchor" href="#越权访问攻击测试" aria-hidden="true">#</a> 越权访问攻击测试：</h4><p>1、改ID; <code>?id=1</code></p><p>2、改用户名；<code>login.php?username=admin</code></p><h4 id="漏洞修复建议" tabindex="-1"><a class="header-anchor" href="#漏洞修复建议" aria-hidden="true">#</a> 漏洞修复建议</h4><p>越权访问漏洞的主要原因是没有对用户的身份做判断和控制，防护这种漏洞可以通过session来控制</p><p>用户登录成功后，把username和UID等信息写入到session中，当查看个人信息时，从session中取出username，而不是从GET和POST取，此时username就是没被篡改的。</p><h2 id="会话劫持" tabindex="-1"><a class="header-anchor" href="#会话劫持" aria-hidden="true">#</a> 会话劫持</h2><p>会话劫持（Session hijacking），是一种通过获取用户 Session ID 后，使用该 Session ID 登录目标账号的攻击方法。</p><p>受害者登录站点，服务器返回一个会话标识(Session ID)</p><p>黑客捕获这个<strong>Session ID</strong>（ 网络嗅探，XSS ），使用这个Session ID访问站点获得受害者合法会话</p><details class="custom-container details"><summary>修复方案</summary><p>会话劫持的第一步是取得一个合法的会话标识来伪装成合法用户，因此需要保证会话标识不被泄漏。</p><p>1、XSS漏洞引起的会话劫持：使用<strong>http-only</strong>来防止JS获取cookie中的Session ID信息</p><p>2、网络嗅探引起的会话劫持：使用<strong>HTTPS+secure</strong>来保证Session ID不被嗅探获取到</p></details><details class="custom-container details"><summary>Session机制</summary><p>Session机制是一种<strong>服务端</strong>的机制，服务器使用一种类似于散列表的结构来保存信息用于保持状态。</p><p>保存这个Session ID最为方便的方式是采用Cookie。Cookie的名字都是类似于SESSIONID；</p><p>Weblogic对于web应用程序生成的cookie，JSESSIONID；</p><p>PHP中Session的默认名称是PHPSESSID。</p></details><details class="custom-container details"><summary>HttpOnly 设置方法</summary><p>服务端发送cookie的时候，可以设置<strong>HTTP-Only</strong> ，禁止 JS 获取Cookie内容</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Set-Cookie</span><span class="token punctuation">:</span> <span class="token header-value">SESSIONID=abc123;HttpOnly;Secure</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>设置Secure为True时， 此cookie只有在HTTPS协议中才会进行传输，HTTP协议传输时，是不传输此协议的</p></details><h2 id="会话固定" tabindex="-1"><a class="header-anchor" href="#会话固定" aria-hidden="true">#</a> 会话固定</h2><p>会话固定（Session fixation）是一种诱骗受害者使用攻击者指定的会话标识（Session ID）的攻击手段。这是攻击者获取合法会话标识的最简单的方法。</p><p>会话固定也可以看成是会话劫持的一种类型，原因是会话固定的攻击的主要目的同样是获得目标用户的合法会话。</p><details class="custom-container details"><summary>漏洞成因</summary><ul><li>访问网站时，网站会设置cookie中的Session ID</li><li><strong>当用户登录后，cookie中的SessionID保持不变</strong>（<strong>形成原因</strong>）</li><li>只要获取登陆前的Session ID内容，就可以知道登陆后的Session ID</li><li>黑客用该Session ID构造链接，发送给受害者点击后，黑客成功劫持受害者的会话</li></ul></details><details class="custom-container details"><summary>修复方案</summary><p>1、在用户登录成功后重新创建一个Session ID，使登录前的匿名会话强制失效</p><p>2、SessionID与浏览器绑定：SessionID与所访问浏览器有变化，立即重置</p><p>3、SessionID与所访问的IP绑定：SessionID与所访问IP有变化，立即重置</p></details><h4 id="漏洞验证" tabindex="-1"><a class="header-anchor" href="#漏洞验证" aria-hidden="true">#</a> 漏洞验证</h4><p>1）访问网站（未登录）：获取cookie信息，获取Session ID</p><p>2）登录网站：查看Cookie信息，获取Session ID</p><p>3）查看登录前，登录后SessionID是否相同（相同即存在此漏洞）</p>`,43),r=[o];function t(d,p){return s(),a("div",null,r)}const l=e(n,[["render",t],["__file","逻辑漏洞.html.vue"]]);export{l as default};
